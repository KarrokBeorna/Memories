import javafx.scene.layout.Pane
import javafx.stage.Stage
import tornadofx.*


class Memories : View("Memories") {

    override val root = Pane (GameFunctionality().root)



    /** Значит, мы смотрим индекс элемента % 8, если он равен 0, то проверяем [index + 1] и [index + 2]
     *                                                  равен 1 , то проверяем [index - 1], [index + 1] и [index + 2]
     *                                                  равен 6, то проверяем [index - 1], [index + 1] и [index - 2]
     *                                                  равен 7, то проверяем [index - 1] и [index - 2]
     *                                    иначе проверяем 2 левые и 2 правые
     * Если верхняя проверка не собрала 3 элементов, то дальше мы смотрим индекс / 8 (предварительно сбросив счётчик),
     *                                          если он равен 0, то проверяем [index + 8] и [index + 16]
     *                                                  равен 1, то проверяем [index - 8], [index + 8] и [index + 16]
     *                                                  равен 6, то проверяем [index - 8], [index + 8] и [index - 16]
     *                                                  равен 7, то проверяем [index - 8] и [index - 16]
     *                                    иначе проверяем 2 верхние и 2 нижние
     * То же самое проделываем с клеткой, которую мы поменяли местами с нашей. По идее мы просто должны поменять
     * их индексы на некоторое время, чтобы облегчить сравнение.
     *
     * Если ни одна из клеток не собрала 3+ в ряд (столбец),
     * то индексы клеток и сами клетки приходят в исходные состояния.
     */

    /**private var killCount = 1
    private fun killingIcons(index: Int){
        when(index % 8) {
            0 -> if(list[index] == list[index + 1]) killCount++
        }
    }
    */

    /** Восстановление кнопок будет происходить также, как и появление начальных элементов, то есть они не образуют
     * сразу 3 одинаковых клетки подряд.
     * Итак, предварительно мы должны узнать индекс первого уничтоженного элемента из прошлой функции, если он
     *            равен 0, то из random() убираем элементы, которые находятся на [index + 1] и [index + 8]
     *            равен 7, то из random() убираем элементы, которые находятся на [index - 1] и [index + 8]
     *            равен 56, то из random() убираем элементы, которые находятся на [index - 8] и [index + 1]
     *            равен 63, то из random() убираем элементы, которые находятся на [index - 8] и [index - 1]
     *            in 1..6, то из random() убираем элементы, которые находятся на [index - 1], [index + 1] и [index + 8]
     *            % 8 = 0, то из random() убираем элементы, которые находятся на [index - 8], [index + 1] и [index + 8]
     *            % 8 = 7, то из random() убираем элементы, которые находятся на [index - 8], [index - 1] и [index + 8]
     *          in 57..62, то из random() убираем элементы, которые находятся на [index - 8], [index - 1] и [index + 1]
     *     иначе из random() убираем элементы, которые находятся на [index - 8], [index - 1], [index + 8] и [index + 1]
     */
    private fun deadIcons() {

    }
}



class MemoriesApp : App(Memories::class) {
        override fun start(stage: Stage) {
            importStylesheet("/style.css")
            super.start(stage)
            stage.isFullScreen =  true
        }
}